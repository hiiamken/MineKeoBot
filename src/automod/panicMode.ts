// src/automod/panicMode.ts

import {
  Guild,
  TextChannel,
  EmbedBuilder,
  GuildMember
} from 'discord.js';
import config from '../config/securityConfig';
import { getRiskScore } from './riskScore';
import { createMinimalSnapshotBackup } from './backupManager';
import { restoreFull } from './restoreManager';

const panicModeGuilds: Set<string> = new Set();
const panicSnapshotMap: Map<string, string> = new Map(); // L∆∞u snapshot ID cho m·ªói guild
const recentActions: Map<string, number[]> = new Map(); // [timestamp, timestamp, ...]
const PANIC_DURATION_MS = 15 * 60 * 1000;
const AUTO_PANIC_ACTION_THRESHOLD = 4;
const ACTION_WINDOW_MS = 30 * 1000;

/**
 * B·∫≠t Panic Mode cho guild.
 * @param guild server
 * @param triggeredBy ID ng∆∞·ªùi k√≠ch ho·∫°t (c√≥ th·ªÉ l√† user.id)
 */
export async function enablePanicMode(guild: Guild, triggeredBy: string) {
  if (panicModeGuilds.has(guild.id)) return;
  panicModeGuilds.add(guild.id);

  // Th√¥ng b√°o k√™nh log
  const logChannel = getLogChannel(guild);
  if (logChannel) {
    const embed = new EmbedBuilder()
      .setColor('Red')
      .setTitle('üõë Panic Mode ƒê√£ B·∫≠t')
      .setDescription(`Panic Mode ƒë∆∞·ª£c k√≠ch ho·∫°t b·ªüi <@${triggeredBy}>.`)
      .setFooter({ text: `Guild ID: ${guild.id}` })
      .setTimestamp();
    await logChannel.send({ embeds: [embed] });
  }

  // Freeze t·∫•t c·∫£ user (tr·ª´ bot, owner, admin)
  for (const member of guild.members.cache.values()) {
    if (
      member.user.bot ||
      member.id === guild.ownerId ||
      member.permissions.has('Administrator')
    ) continue;
    await freezeUser(guild, member.id);
  }

  // (Tu·ª≥ ch·ªçn) T·∫°o snapshot backup nhanh
  // N·∫øu b·∫°n mu·ªën rollback, c√≥ th·ªÉ l∆∞u snapshotId
  // const snapshotId = await createMinimalSnapshotBackup(guild);
  // panicSnapshotMap.set(guild.id, snapshotId);

  // T·ª± ƒë·ªông t·∫Øt sau X ms (n·∫øu c√≥ c·∫•u h√¨nh)
  const autoDisableMs = config.antiNuke?.panicMode?.autoDisableAfterMs || PANIC_DURATION_MS;
  setTimeout(() => {
    disablePanicMode(guild, 'System (Timeout)');
  }, autoDisableMs);
}

/**
 * T·∫Øt Panic Mode cho guild (th·ªß c√¥ng ho·∫∑c t·ª± ƒë·ªông).
 */
export async function disablePanicMode(guild: Guild, triggeredBy: string) {
  if (!panicModeGuilds.has(guild.id)) return;
  panicModeGuilds.delete(guild.id);

  const logChannel = getLogChannel(guild);
  if (logChannel) {
    const embed = new EmbedBuilder()
      .setColor('Green')
      .setTitle('‚úÖ Panic Mode ƒê√£ T·∫Øt')
      .setDescription(`Panic Mode ƒë∆∞·ª£c t·∫Øt b·ªüi: ${triggeredBy}`)
      .setFooter({ text: `Guild ID: ${guild.id}` })
      .setTimestamp();
    await logChannel.send({ embeds: [embed] });
  }

  // M·ªü kh√≥a (unfreeze) t·∫•t c·∫£ user ƒë√£ b·ªã freeze
  await unfreezeAllUsers(guild);

  // (N·∫øu c√≥ snapshot, c√≥ th·ªÉ x√≥a ho·∫∑c rollback tu·ª≥ logic)
  // panicSnapshotMap.delete(guild.id);
}

/**
 * Ki·ªÉm tra guild c√≥ ƒëang ·ªü Panic Mode hay kh√¥ng.
 */
export function isPanicModeActive(guildId: string) {
  return panicModeGuilds.has(guildId);
}

/**
 * Freeze 1 user b·∫±ng c√°ch g√°n h·ªç v√†o role "Frozen".
 */
export async function freezeUser(guild: Guild, userId: string) {
  try {
    const member = await guild.members.fetch(userId);
    if (!member) return;
    const freezeRole = await getOrCreateFreezeRole(guild);
    await member.roles.add(freezeRole, 'Panic Mode: Freeze user nghi ng·ªù');
    console.log(`[PanicMode] ƒê√£ freeze user ${member.user.tag}`);
  } catch (err) {
    console.error(`[PanicMode] L·ªói khi freeze user ${userId}:`, err);
  }
}

/**
 * Unfreeze 1 user (g·ª° role "Frozen").
 */
export async function unfreezeUser(guild: Guild, userId: string) {
  try {
    const member = await guild.members.fetch(userId);
    if (!member) return;
    const freezeRole = await getOrCreateFreezeRole(guild);
    if (member.roles.cache.has(freezeRole.id)) {
      await member.roles.remove(freezeRole, 'Panic Mode: Unfreeze user');
      console.log(`[PanicMode] ƒê√£ unfreeze user ${member.user.tag}`);
    }
  } catch (err) {
    console.error(`[PanicMode] L·ªói khi unfreeze user ${userId}:`, err);
  }
}

/**
 * Unfreeze to√†n b·ªô user trong server.
 */
export async function unfreezeAllUsers(guild: Guild) {
  const freezeRole = await getOrCreateFreezeRole(guild);
  for (const member of guild.members.cache.values()) {
    if (member.roles.cache.has(freezeRole.id)) {
      await member.roles.remove(freezeRole, 'Panic Mode: Unfreeze all');
    }
  }
  console.log(`[PanicMode] ƒê√£ unfreeze t·∫•t c·∫£ user trong server ${guild.name}.`);
}

/**
 * T·∫°o (ho·∫∑c l·∫•y) role "Frozen" ƒë·ªÉ freeze user.
 */
async function getOrCreateFreezeRole(guild: Guild) {
  const roleName = config.antiNuke?.panicMode?.freezeRoleName || 'Frozen';
  let role = guild.roles.cache.find(r => r.name === roleName);
  if (!role) {
    role = await guild.roles.create({
      name: roleName,
      permissions: [],
      reason: 'Panic Mode: T·∫°o role freeze'
    });
    console.log(`[PanicMode] ƒê√£ t·∫°o role "${roleName}" cho server ${guild.name}.`);
  }
  return role;
}

/**
 * L·∫•y k√™nh log n·∫øu c√≥ c·∫•u h√¨nh.
 */
function getLogChannel(guild: Guild): TextChannel | null {
  const channelId = config.restore?.logChannelId;
  const channel = guild.channels.cache.get(channelId || '');
  return (channel && channel.isTextBased()) ? (channel as TextChannel) : null;
}

/**
 * Khi ph√°t hi·ªán h√†nh vi nguy hi·ªÉm, g·ªçi h√†m n√†y ƒë·ªÉ k√≠ch ho·∫°t Panic Mode theo risk score.
 */
export async function maybeTriggerPanicByRisk(guild: Guild, userId: string) {
  const score = await getRiskScore(guild.id, userId);
  if (score >= 30 && !isPanicModeActive(guild.id)) {
    await enablePanicMode(guild, userId);
  }
}

/**
 * Khi ph√°t hi·ªán nhi·ªÅu h√†nh ƒë·ªông li√™n ti·∫øp, g·ªçi h√†m n√†y ƒë·ªÉ k√≠ch ho·∫°t Panic Mode.
 */
export async function maybeTriggerPanicByRapidEvents(guild: Guild, userId: string) {
  const now = Date.now();
  const key = `${guild.id}-${userId}`;
  const list = recentActions.get(key) || [];
  // L·ªçc c√°c event c≈© h∆°n ACTION_WINDOW_MS
  const updated = [...list.filter(t => now - t <= ACTION_WINDOW_MS), now];
  recentActions.set(key, updated);

  // N·∫øu s·ªë event li√™n ti·∫øp >= AUTO_PANIC_ACTION_THRESHOLD => b·∫≠t Panic Mode
  if (updated.length >= AUTO_PANIC_ACTION_THRESHOLD && !isPanicModeActive(guild.id)) {
    await enablePanicMode(guild, userId);
    recentActions.set(key, []); // reset sau khi k√≠ch ho·∫°t
  }
}

/**
 * H√†m rollbackPanic cho ph√©p kh√¥i ph·ª•c server v·ªÅ snapshot
 * ƒë√£ ƒë∆∞·ª£c t·∫°o khi b·∫≠t Panic Mode (n·∫øu c√≥).
 */
export async function rollbackPanic(guild: Guild): Promise<void> {
  // Gi·∫£ s·ª≠ b·∫°n c√≥ map panicSnapshotMap: Map<string, string> l∆∞u snapshot ID
  if (!panicSnapshotMap.has(guild.id)) {
    console.warn(`[PanicMode] Kh√¥ng c√≥ snapshot ƒë·ªÉ rollback cho guild ${guild.name}.`);
    return;
  }
  const snapshotId = panicSnapshotMap.get(guild.id)!;
  console.log(`[PanicMode] Rollback server ${guild.name} v·ªÅ snapshot ${snapshotId}`);
  await restoreFull(guild, snapshotId);
  // Sau khi rollback, c√≥ th·ªÉ xo√° snapshot kh·ªèi map
  panicSnapshotMap.delete(guild.id);
}